import * as actionTypes from './actionTypes';
import axios from '../../axios-orders';


/*
    Actions are consumed by reducer cases. Actions could be 
    created as objects directly or could be generated by action
    creators. Action creators are functions which generate and return
    an object that is expected from a component when that component
    dispatches an action, so these action creators could be used 
    inside mapDispatchToProps.

    Due to <thunk> middleware it is possible to use async code inside
    action creators. These action creators will not return the action
    to reducer until async logic is completed
*/

/*
    sync action type creators for burger building
*/

export const addIngredient = (ingredientName) => {
    return {
        type: actionTypes.ADD_INGREDIENT,
        ingredientName: ingredientName
    }
};

export const removeIngredient = (ingredientName) => {
    return {
        type: actionTypes.REMOVE_INGREDIENT,
        ingredientName: ingredientName
    }
};

export const fetchIngredientsFailed = () => {
    return {
        type: actionTypes.FETCH_INGREDIENTS_FAILED
    }
}

export const setIngredients = (ingredients) => {
    return {
        type: actionTypes.SET_INGREDIENTS,
        ingredients: ingredients
    }
}



/* 
    async action type creators for making an order
*/

export const initIngredients = () => {
    return (
        (dispatch) => {
            /*
                Note that if you'd like to test the catch error functionality
                you might change URL to '/ingredients' this will reject the 
                promise thus triggering the .catch section of the code

                However, the Firebase backend will still return 200 OK response
                if you change URL to '/random.json', keep this mind. This behaviour
                of Firebase (this might be an issue with axios though?) have not been
                taken into account here
            */
            axios.get('/ingredients.json')
                .then(response => {
                    dispatch(setIngredients(response.data));
                })
                .catch(error => {
                    dispatch(fetchIngredientsFailed());
                })
        }
    );
};