import * as actionTypes from './actionTypes';
import axios from '../../axios-orders';


/*
    Actions are consumed by reducer cases. Actions could be 
    created as objects directly or could be generated by action
    creators. Action creators are functions which generate and return
    an object that is expected from a component when that component
    dispatches an action, so these action creators could be used 
    inside mapDispatchToProps.

    Due to <thunk> middleware it is possible to use async code inside
    action creators. These action creators will not return the action
    to reducer until async logic is completed
*/

/*
    sync action type creators for making an order
*/

export const purchaseBurgerSuccess = (id, orderData) => {
    return {
        type: actionTypes.PURCHASE_BURGER_SUCCESS,
        orderId: id,
        orderData: orderData
    }
}

export const purchaseBurgerFail = (error) => {
    return {
        type: actionTypes.PURCHASE_BURGER_SUCCESS,
        error: error
    }
}

export const purchaseBurgerStart = () => {
    return {
        type: actionTypes.PURCHASE_BURGER_START
    }
}

export const purchaseInit = () => {
    return {
        type: actionTypes.PURCHASE_INIT
    }
}

/*
    sync action type creators for fetching 'my' orders
*/

export const fetchOrdersSuccess = (orders) => {
    return {
        type: actionTypes.FETCH_ORDERS_SUCCESS,
        orders: orders
    }
}

export const fetchOrdersFail = (error) => {
    return {
        type: actionTypes.FETCH_ORDERS_FAIL,
        error: error
    }
}

export const fetchOrdersStart = () => {
    return {
        type: actionTypes.FETCH_ORDERS_START
    }
}



/* 
    async action type creators for making an order
*/
export const purchaseBurger = (orderData, token) => {
    return dispatch => {
        /*
            we are using Firebase, so we did not create an API endpoint
            to handle our requests. But they will get created magically,
            for this to work we need to specify a namespace where all
            key-value pairs will be created like this:
                
                /<namespace>.json

            Note that below path will be appended to the baseURL to send
            the post request
        */
        dispatch(purchaseBurgerStart());
        axios.post("/orders.json?auth=" + token, orderData)
            .then(response => {
                console.log("Order placed!");
                dispatch(purchaseBurgerSuccess(response.data.name, orderData));
            })
            .catch(error => {
                console.log("ERROR: could not place the order!")
                dispatch(purchaseBurgerFail(error));
            })

    };
}



/* 
    async action type creators for fetching 'my' orders
*/
export const fetchOrders = (token, userId) => {
    return dispatch => {
        /*
            we are using Firebase, so we did not create an API endpoint
            to handle our requests
        */
        dispatch(fetchOrdersStart());

        /*
            IMPORTANT: for the below query params to work your rules on
                       firebase should look like this (note the '.indexOn'):

                    {
                        "rules": {
                            "ingredients": {
                                ".read": true,
                                ".write": true
                            },
                            "orders": {
                                ".indexOn": "userId",
                                ".read": "auth != null",
                                ".write": "auth != null"
                            }    
                        }
                    }

        */
        const queryParams = `?auth=${token}&orderBy="userId"&equalTo="${userId}"`;

        axios.get('/orders.json' + queryParams)
            .then((response) => {
                const fetchedOrders = [];
                for (let order_key in response.data) {
                    fetchedOrders.push({
                        ...response.data[order_key],
                        id: order_key
                    });
                }
                dispatch(
                    fetchOrdersSuccess(fetchedOrders)
                );
            })
            .catch(error => {
                dispatch(
                    fetchOrdersFail(error)
                );
            })

    };
}